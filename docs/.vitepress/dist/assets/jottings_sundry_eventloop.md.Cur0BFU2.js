import{_ as p,c as k,l as s,I as i,w as e,a as h,aV as a,D as t,o as r}from"./chunks/framework.BDfjdzks.js";const q=JSON.parse('{"title":"浏览器事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"jottings/sundry/eventloop.md","filePath":"jottings/sundry/eventloop.md","lastUpdated":1719236634000}'),o={name:"jottings/sundry/eventloop.md"},d=a('<h1 id="浏览器事件循环" tabindex="-1">浏览器事件循环 <a class="header-anchor" href="#浏览器事件循环" aria-label="Permalink to &quot;浏览器事件循环&quot;">​</a></h1><h2 id="_1-概念" tabindex="-1">1. 概念 <a class="header-anchor" href="#_1-概念" aria-label="Permalink to &quot;1. 概念&quot;">​</a></h2><hr><h3 id="程序" tabindex="-1">程序 <a class="header-anchor" href="#程序" aria-label="Permalink to &quot;程序&quot;">​</a></h3><blockquote><p>程序是一组计算机或其他执行系统能识别和执行的<span color="#00b050">指令序列</span> , 具体到实物上可以理解成我们使用各种编程语言所书写的各种代码指令</p></blockquote><hr><h3 id="进程" tabindex="-1">进程 <a class="header-anchor" href="#进程" aria-label="Permalink to &quot;进程&quot;">​</a></h3><blockquote><p>进程是指操作系统中管理和调度计算资源的基本单元,<strong>可以简单理解为正在执行中的程序和其所被执行时所分配的内存空间</strong></p></blockquote><div class="tip custom-block"><p class="custom-block-title">提示</p><ul><li><strong>在操作系统中每个进程都有自己独立的内存空间,一个进程下可以拥有多个线程, 当内存被回收那么其下面的各个线程也会被杀死,</strong></li></ul><ul><li><strong>浏览器中存在多个线程:</strong><ul><li>主进程(Browser process): 协调管理其他进程,负责浏览器界面显示、用户交互、子进程的管理和通信等。</li><li>网络进程(Network process): 负责网络资源的加载,处理网络请求</li><li>插件进程(Plugin process): 负责插件的运行,处理插件内容</li><li>GPU进程(GPU process ): 处理页面的3D绘制及其他与 <code>GPU</code> 相关的任务,</li><li><b color="#f00">渲染进程(Renderer process ==&gt;事件循环所在的进程)</b>: 浏览器的每个标签页都有自己的渲染进程, 主要负责页面渲染,解析<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>等内容,并将渲染结果显示在页面上</li></ul></li></ul></div><hr><h3 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h3><blockquote><p>线程是<b color="#f00">进程中</b>的执行单元(具体干活的人,他是程序指令序列的执行者),一个进程可以拥有多个线程,每个线程都有自己的堆栈、局部变量等,但线程间共享进程的内存空间和其他公共资源--&gt;(房子内干活的多个人都可以使用房间内的各种资源,如全局变量,文件资源等..)</p></blockquote><div class="tip custom-block"><p class="custom-block-title">提示</p><p><strong>进程被创建的时候,会默认创建一个主线程,主线程在执行代码过程中可能会根据需要来创建一些子线程,这些线程之间可以同步和通信,然后通过合理的调度和分配,使得多个线程可以并发地执行不同的任务。</strong></p></div><h2 id="_2-浏览器事件循环" tabindex="-1">2. 浏览器事件循环 <a class="header-anchor" href="#_2-浏览器事件循环" aria-label="Permalink to &quot;2. 浏览器事件循环&quot;">​</a></h2><h3 id="_2-1-渲染主线程" tabindex="-1">2.1. 渲染主线程 <a class="header-anchor" href="#_2-1-渲染主线程" aria-label="Permalink to &quot;2.1. 渲染主线程&quot;">​</a></h3><blockquote><p>渲染进程下的主线程,负责解析<code>HTML</code>、<code>CSS</code>、执行<code>JavaScript</code>等工作,</p></blockquote><h3 id="_2-2-子线程" tabindex="-1">2.2. 子线程 <a class="header-anchor" href="#_2-2-子线程" aria-label="Permalink to &quot;2.2. 子线程&quot;">​</a></h3><blockquote><p>交互线程,计时线程,异步IO线程等...,配合主线程,通过各线程间通信和合理调度来完成多个任务并发执行的线程</p></blockquote><h3 id="_2-3-消息队列" tabindex="-1">2.3. 消息队列 <a class="header-anchor" href="#_2-3-消息队列" aria-label="Permalink to &quot;2.3. 消息队列&quot;">​</a></h3><blockquote><p>存放待执行任务的队列,主线程不断从消息队列中取出可执行任务并执行</p></blockquote><p><b color="#646cff">消息队列中的待执行任务由主线程以及各个子线程添加,根据任务类型(<code>taskType</code>)的不同来决定将当前任务添加到哪个消息队列中</b></p><h3 id="_2-4-js同步执行阻塞" tabindex="-1">2.4. js同步执行阻塞: <a class="header-anchor" href="#_2-4-js同步执行阻塞" aria-label="Permalink to &quot;2.4. js同步执行阻塞:&quot;">​</a></h3>',22),c={class:"details custom-block"},B=a(`<summary>js的执行阻塞页面的渲染</summary><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;给我一个div&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;按钮&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> h</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> button</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;button&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 延时函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> now</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> now</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) { };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        button</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            h</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">innerText</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 9999</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            //h1元素内容已更改,但页面不会立即显示,渲染任务被阻塞,直到delay函数执行完毕</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;h.innerText&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">innerText</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">            delay</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="" tabindex="-1">::: <a class="header-anchor" href="#" aria-label="Permalink to &quot;:::&quot;">​</a></h2><blockquote><p>代码在执⾏过程中，会遇到⼀些⽆法⽴即处理的任务，⽐如：</p><ul><li>计时完成后需要执⾏的任务 —— <code>setTimeout</code> 、 <code>setInterval</code></li><li>⽹络通信完成后需要执⾏的任务 -- <code>XHR</code> 、 <code>Fetch</code></li><li>⽤户操作后需要执⾏的任务 -- <code>addEventListener</code></li></ul></blockquote><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从⽽导致浏览器「卡死」</p>`,5),g=s("h3",{id:"_2-5-js异步执行",tabindex:"-1"},[h("2.5. js异步执行: "),s("a",{class:"header-anchor",href:"#_2-5-js异步执行","aria-label":'Permalink to "2.5. js异步执行:"'},"​")],-1),y=a('<hr><h3 id="_2-6-事件循环" tabindex="-1">2.6. 事件循环 <a class="header-anchor" href="#_2-6-事件循环" aria-label="Permalink to &quot;2.6. 事件循环&quot;">​</a></h3><hr><p>事件循环也叫消息循环,是浏览器 <b>渲染主线程的工作方式</b>,这是一个非常繁忙的线程,它负责解析<code>css</code>,<code>html</code>,执行<code>js</code>,渲染页面等繁杂的工作,但有时候需要处理的任务是非常耗时(异步)的,比如<code>网络请求,定时器,事件处理回调</code>等...,这些都不是可以立即可以执行的任务,如果让主线程一直等待的话那会导致页面的阻塞,所以主线程会开启一些子线程来协同完成工作,将这些耗时任务交给对应的子线程去处理,而主线程继续执行其他的代码,当这些耗时任务达到可执行条件的时候,会被子线程添加到对应的消息(任务)队列中等待主线程来执行 <br> 主线程代码执行完成后,会到消息队列中查看是否有可执行任务,有的话就取出执行,没有的话就等待新的任务到来,主线程这种不断执行代码,去任务队列中取任务执行的往复过程就是事件循环 js同步执行时的效果:</p><div class="tip custom-block"><p class="custom-block-title">提示</p><ul><li><strong>关于任务(消息)队列:</strong> <br> 过去是把任务队列分为宏队列和微队列,但现在的浏览器并没有宏队列的概念,而是增加了其他一系列具体的队列(如:延时队列,交互队列等等),W3C规定的是同类型的任务必须在同一队列,任务本身没有优先级,但不同的任务队列有不同的优先级,浏览器必须有一个微队列,微队列具有最高的优先级,每一次事件循环中主线程会优先到微队列中查看是否有可执行任务,如果没有才会去其他队列查看其他任务,添加任务到微队列的方式有: <code>Promise的then方法回调,MutationObserver的DOM变动回调</code></li></ul><hr><ul><li><strong>关于消息循环:</strong> <br> 在<code>Chrome</code>的源码中, 它会开启一个不会结束的for循环(C++编写),每次循环从消息队列中取出第一个任务执行,而其他线程在合适的时候将任务加入到队列末尾等待执行即可</li></ul></div>',5);function b(u,E,A,_,m,C){const n=t("a-image"),l=t("DemoBlock");return r(),k("div",null,[d,s("details",c,[B,i(l,null,{default:e(()=>[i(n,{preview:"",src:"/docs/images/javaScript/js同步执行.png"})]),_:1}),g,s("blockquote",null,[s("p",null,[h("js采用一步去来解决主线程阻塞问题 "),i(l,null,{default:e(()=>[i(n,{preview:"",src:"/docs/images/javaScript/js异步执行.png"})]),_:1})])]),y])])}const D=p(o,[["render",b]]);export{q as __pageData,D as default};
